# upc-matt-nsaa
Repo to allocate NSAA web auth class examples

## Lab 2: WebAuth using Express.js and Passport.js

### 6.1. Exchange the JWT using cookies
When a user has successfully authenticated himself with the local strategy, a token is created and signed with the `jwtSecret` of the server. If any cookie has been created yet, the server creates a new one with the JWT token on it and it is attached to the `res` object. Then the server redirects to the root of the site to tell the fortune to the user. The cookie expires after the milliseconds on the variable `cookieExpire`. When this happens, a message is registered on the log and also an alert pops up to the user using the webpage. 

### 6.2. Create the fortune-teller endpoint
When the user provides the credentials, the `JWTStrategy` is used to authenticate. The configuration of that strategy is quite simple. It only needs the `cookieExtractor` function (can be found ond [passport.js docs](http://www.passportjs.org/packages/passport-jwt/#extracting-the-jwt-from-the-request)) and the `jwtSecret`. Now, a browser providing a cookie with a valid JWT (verified by the server) is able to access the fortune teller without providing the login credentials. 

The random fortune generated by the server, the username of authenticated user and the expire time of the cookie will be available on the fortune teller html view and are used on it. This is possible by configuring express properly and use the `res.render` function.

### 6.3. Add a logout endpoint
The logout endpoint simply clears the cookie on the `res` object and also stops the timer counting the expire time. Also an information message is logged.

### 6.4. Add bcrypt or scrypt to the login process
I created a `MongoDB` user model with `Mongoose`. This model hashes the introduced password before saving it on the database. It also has a method to verify an introduced password provided by `bcrypt`. That model is used on the `LocalStrategy` configuration in a quite simple way. 